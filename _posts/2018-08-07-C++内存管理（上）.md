---
layout: post
title: C++内存管理（上）
date: 2018-08-07 21:00:24.000000000 +08:00
---

C++的内存管理是一把双刃剑，高手从中获得了更好的性能和更大自由，而菜鸟则大多在之中挣扎不已。想成为C++高手，内存管理是必须要啃下的硬骨头。

**一、内存分配方式**

在C++中，内存分成5个区，他们分别是**堆、栈、自由存储区、全局/静态存储区和常量存储区。**

栈：执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。

堆：由`new`分配的内存块，它们的释放编译器不去管，由我们的应用程序去控制，一般一个`new`就要对应一个`delete`。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。

自由存储区：那些由`malloc`等分配的内存块，它和堆是十分相似的，不过它是用`free`来结束自己的生命的。

全局/静态存储区：全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，共同占用同一块内存区。

常量存储区：这是一块比较特殊的存储区，里面存放的是常量，不允许修改。

**二、堆与栈的区分**

对于新手来说，区分堆和栈是必须要迈过的坎。

	void f()
	{
		int* p = new int[5];
		...
		delete []p；
	}

在上面这个函数中，看到new，就表示分配了一块堆内存；而指针P分配的是一块栈内存。所以这句话的意思是：**在栈内存中存放了一个指向一块堆内存的指针P。**在内存使用完毕之后，需要用delete释放堆内存。

**堆与栈的区别**

- 管理方式：栈由编译器自动管理；堆的创建和释放由程序员控制，控制不好容易造成内存泄漏。
- 空间大小：栈通常有一定的空间大小；而堆内存几乎没什么限制。
- 碎片问题：对于堆内存来说，频繁的new/delete必然会造成内存空间的不连续，碎片多，使程序效率降低；而在栈中不会存在这个问题。
- 生长方向：堆的生长方向是沿着内存地址增加的方向；栈则相反。
- 分配方式：所有的堆都是动态分配的，不允许静态分配；栈可以支持动/静分配，静态分配是编译器完成的，比如局部变量的分配。动态分配由`alloca`函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。
- 分配效率：是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高；堆则是C/C++函数库提供的，它的机制是很复杂的，堆的效率比栈要低得多。

综上所述，在编程中我们要尽量多使用栈，少使用堆。但如果需要分配大量内存空间时，还是需要用堆。

**三、常见的内存错误及对策**

内存错误是编译器无法发现的，只能在程序运行时捕捉，而且时隐时现，改起来很困难。下面列出常见的内存错误及对策：

- 内存分配未成功却使用：解决方法是在使用内存之前检查指针是否为NULL。
- 内存分配虽然成功但未初始化就引用：在创建指针或数组时记得赋初值，即便是零值也有必要。
- 内存已经初始化但越界：在数组下标、循环语句等地方进行越界检查。
- 忘记释放内存导致泄漏：保证malloc/free、new/delete的出现次数一定要相同。
- 释放了内存却继续使用：注意不要返回指向栈内存的指针或者引用，这些在函数体结束时已经被自动销毁。同时，避免野指针产生，即在用free/delete释放内存之后，要立即将指针设置为NULL。