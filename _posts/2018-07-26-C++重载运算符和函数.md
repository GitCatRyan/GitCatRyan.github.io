---
layout: post
title: C++重载运算符和函数
date: 2018-07-26 21:40:24.000000000 +08:00
---

C++ 允许在同一作用域中的某个函数和运算符指定多个定义，分别称为函数重载和运算符重载。

换句话说，**重载就是对相同名称的函数或运算符赋予不同的含义和实现。**

那么问题来了，两个函数或者运算符名字都相同，编译器怎么知道我调用的是哪个？

当调用一个重载函数或重载运算符时，编译器通过把使用的参数类型与定义中的参数类型进行比较，决定选用最合适的定义。这个过程，称为**重载决策**。

**函数重载**

在同一个作用域内，可以声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同。不能仅通过返回类型的不同来重载函数。

下面的实例中，同名函数 print() 被用于输出不同的数据类型：

	#include <iostream>
	
	using namespace std;
 
	class printData
	{
		public:
      		void print(int i) 
      		{
        		cout << "整数为: " << i << endl;
      		}
 
      		void print(double  f) 
     		{
        		cout << "浮点数为: " << f << endl;
      		}
 
      		void print(char c[]) {
        		cout << "字符串为: " << c << endl;
      		}
	};
 
	int main(void)
	{
		printData pd;
 
		// 输出整数
		pd.print(5);
		// 输出浮点数
		pd.print(500.263);
		// 输出字符串
		char c[] = "Hello C++";
		pd.print(c);
 
		return 0;
	}

**运算符重载**

可以重定义或重载大部分C++内置的运算符，这样就能使用自定义类型的运算符。

重载的运算符是带有特殊名称的函数，函数名是由关键字operator和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。

	Box operator+(const Box&);

上面的声明加法运算符用于把两个Box对象（1个是传入的Box，1个是this指针指向的自身Box）相加，返回最终的Box对象。

如果我们定义上面的函数为类的非成员函数，那么我们需要为每次操作传递两个参数，如下所示：

	Box operator+(const Box&, const Box&);

**可/不可重载的运算符**

可重载的运算符包括：

- 双目算术运算符：`+`  `-`  `*`  `/`  `%`
- 关系运算符：`==`  `!=`  `<`  `>`  `<=`  `>=`
- 逻辑运算符：`||`  `&&`  `！`
- 单目运算符：`+`(正)  `-`(负)  `*`(指针)  `&`(取地址)
- 自增自减运算符
- 位运算符：`|`  `&`  `~`  `^`  `<<`  `>>`
- 赋值运算符：`=`  `+=`  `-=`  `*=`  `/=`  `%=`  `&=`  `|=`  `^=`  `<<=`  `>>=`
- 空间申请与释放：`new`  `delete`  `new[]`  `delete[]`
- 其他运算符：`()`(函数调用)  `->`(成员访问)  `,`(逗号)  `[]`(下标)

不可重载的运算符包括：

- `.`：成员访问运算符
- `.*`, `->*`：成员指针访问运算符
- `::`：域运算符
- `sizeof`：长度运算符
- `?:`：条件运算符
- `#`：预处理符号